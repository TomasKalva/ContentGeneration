//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.10
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------


using System;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Globalization;

namespace Noesis
{

[StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
public struct Point3D {

  [MarshalAs(UnmanagedType.R4)]
  private float _x;

  [MarshalAs(UnmanagedType.R4)]
  private float _y;

  [MarshalAs(UnmanagedType.R4)]
  private float _z;

  public float X {
    get { return this._x; }
    set { this._x = value; }
  }

  public float Y {
    get { return this._y; }
    set { this._y = value; }
  }

  public float Z {
    get { return this._z; }
    set { this._z = value; }
  }

  public Point3D(float x, float y, float z) {
    this._x = x;
    this._y = y;
    this._z = z;
  }

  public void Offset(float offsetX, float offsetY, float offsetZ) {
    _x += offsetX;
    _y += offsetY;
    _z += offsetZ;
  }

  public static Point3D operator+(Point3D point, Vector3D vector) {
    return new Point3D(point._x + vector.X, point._y + vector.Y, point._z + vector.Z);
  }

  public static Point3D Add(Point3D point, Vector3D vector) {
    return new Point3D(point._x + vector.X, point._y + vector.Y, point._z + vector.Z);
  }

  public static Point3D operator-(Point3D point, Vector3D vector) {
    return new Point3D(point._x - vector.X, point._y - vector.Y, point._z - vector.Z);
  }

  public static Point3D Subtract(Point3D point, Vector3D vector) {
    return new Point3D(point._x - vector.X, point._y - vector.Y, point._z - vector.Z);
  }

  public static Vector3D operator-(Point3D point1, Point3D point2) {
    return new Vector3D(point1._x - point2._x, point1._y - point2._y, point1._z - point2._z);
  }

  public static Vector3D Subtract(Point3D point1, Point3D point2) {
    return new Vector3D(point1._x - point2._x, point1._y - point2._y, point1._z - point2._z);
  }

  public static Point3D operator*(Point3D point, Matrix3D matrix) {
    return matrix.Transform(point);
  }

  public static Point3D Multiply(Point3D point, Matrix3D matrix) {
    return matrix.Transform(point);
  }

  public static explicit operator Vector3D(Point3D point) {
    return new Vector3D(point._x, point._y, point._z);
  }

  public static bool operator==(Point3D point1, Point3D point2) {
    return point1.X == point2.X && point1.Y == point2.Y && point1.Z == point2.Z;
  }

  public static bool operator!=(Point3D point1, Point3D point2) {
    return !(point1 == point2);
  }

  public static bool Equals(Point3D point1, Point3D point2) {
    return point1.X.Equals(point2.X) && point1.Y.Equals(point2.Y) && point1.Z.Equals(point2.Z);
  }

  public override bool Equals(object o) {
    if (o == null || !(o is Point3D)) {
      return false;
    }
    Point3D point = (Point3D)o;
    return Equals(this, point);
  }

  public bool Equals(Point3D value) {
    return Equals(this, value);
  }

  public override int GetHashCode() {
    return X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode();
  }

  public override string ToString() {
    return String.Format("{0},{1},{2}", X, Y, Z);
  }

  public static Point3D Parse(string str) {
    Match match = sRegex.Match(str);
    if (match.Success) {
      float x = float.Parse(match.Groups[1].Value, CultureInfo.InvariantCulture);
      float y = float.Parse(match.Groups[2].Value, CultureInfo.InvariantCulture);
      float z = float.Parse(match.Groups[3].Value, CultureInfo.InvariantCulture);
      return new Point3D(x, y, z);
    }
    throw new ArgumentException("Cannot create Point3D from '" + str + "'");
  }

  private static string sParseExpression = @"\s*(.*[^,\s])\s*[,\s]\s*(.*[^,\s])\s*[,\s]\s*(.*[^,\s])\s*";
  private static Regex sRegex = new Regex(sParseExpression);

}

}

