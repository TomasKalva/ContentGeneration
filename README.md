## Introduction

OurFramework is a framework for fast prototyping of 3D soulslike action RPG games. The gameplay can be created by using C# scripts which make use of already existing libraries for creation of bulidings, enemies, items and much more. 

Creation of 3D action RPGs is a complex and time consuming process. OurFramework helps the designer to focus on the important tasks while minimizing the need to focus on repetitive actions and to write boilerplate code. OurFramework also provides user with existing assets such as models for environment and enemies and visual effects. 

This tutorial covers all the steps needed to create a game using OurFramework.  The reader should be familiar with programming in C#. Most of the C# concepts needed to understand this tutorial can be found [here](https://learnxinyminutes.com/docs/csharp/).

# Installing framework

<!--To see how the framework is implemented internally, please refer to the [documentation][documentation].

[documentation]: ???-->

We used the Windows operating system when writing and using the framework.

The framework uses Unity, a game engine that can be downloaded for free [here](https://unity.com/pricing#plans-student-and-hobbyist). The project uses Unity version 2021.2.3f1.

The IDE we use for code editing is Visual Studio 2022 which can be downloaded for free [here](https://visualstudio.microsoft.com/free-developer-offers/). It offers some features that greatly improve coding experience and are therefore used regularly in this tutorial:
 * Navigating to declaration of a method/variable in visual studio can be done using `Ctrl` + `Left mouse button` click on the symbol.
 * Hovering over method name shows its declaration.
 * When a name of class from unreferenced namespace is used, the using statement can be automatically generated by pressing `Alt` + `Enter`. The code containts a lot of references to namespaces and so explicitly mentioning their usage would make the text harder to read. For that reason we don't mention their usage explicitly.

The Unity project can be downloaded [here]. The generator can be run by simply navigating to the scene `Assets/Scenes/ShapeGrammar` and running it. The project uses an external library for user interface, that uses a license. It is not necessary to set the license, but without it the screen will be covered after some time of running the game. A free trial license can be obtained [here](https://www.noesisengine.com/trial/) and pasted to `Resources/NoesisSettings`.

# A simple level

In this part of the tutorial we will create a simple game with a few buildings, enemies and items.

## Creating a new game

As you probably noticed, the framework contains a lot of scripts and directories. Don't worry about it, for now we will only focus on the core of the framework that is necessary to create a simple game and later on gradually explore more options how to extend the game using more advanced features.

The philosophy of OurFramework is to be able to customize as much as the game logic as possible using simple C# scripts. Because the logic can get complicated quite quickly, the scripts are split into modules each of which focuses on a smaller task. The modules are then used to declare what the game should contain.

Let's create a simple module to see how modules work in practice. The module will allow us to start a game with a single building. 

First let's navigate to the folder `AssetsFolderName/LevelDesignLanguage/Modules`. You should see multiple already created modules each put into its own `.cs` file. We will put our new module into a new file too so let's create a new class file called `TutorialModule.cs`. Copy and paste the following code to the file:

```C#
using OurFramework.Environment.ShapeGrammar;

namespace OurFramework.LevelDesignLanguage.CustomModules
{
    class TutorialModule : LDLanguage
    {
        public TutorialModule(LanguageParams parameters) : base(parameters) { }
        
        public void Main()
        {
            LevelStart();
        }

        void LevelStart()
        {
            Env.One(Gr.PrL.CreateNewHouse(), NodesQueries.All, out var area);
            area.Get.Node.AddSymbol(Gr.Sym.LevelStartMarker);
        }
    }
}
```

The newly created `TutorialModule` derives from `LDLanguage`, because it contains objects that will be useful once we start creating the game. The objects are initialized using `LanguageParams` passed to the constructor. It contains two methods:
* `Main` - will be used to define the structure of the level,
* `LevelStart` - creates the initial area.
 
Before the game is started the method `DeclareGame` of the module `MainModule` is called. The method contains declaration of events that will get called once the game starts. The method currently contains call to `StartDebugGame` which starts a new game using the already existing modules. We will create the entire game from scratch so to comment out the line with `StartDebugGame();` and add declaration of event from our module the following way:

```C#
...
public void DeclareGame()
{
    //StartDebugGame();
    State.LC.AddNecessaryEvent($"Tutorial module", 100, level => M.TutorialModule.Main());
}
...
```

At this point the compiler should complain about `TutorialModule`. `M` is an object that should contain references to all existing modules. We need to add our module to it as a property called `TutorialModule`. Navigate to the C# file `AssetsFolderName/LevelDesignLanguage/Modules.cs` and add the following property to the class `Modules`:

```C#
...
public TutorialModule TutorialModule { get; private set; }
...
```

We have to initialize it before being able to use it so add call constructor of `TutorialModule` in the method `Initialize`:

```C#
public void Initialize(LanguageParams languageParams)
{
    ...
    TutorialModule = new TutorialModule(languageParams);
}
```

Now we can go back to Unity and press play. If you've done everything correctly, you should see a similar result:

![Player in a room](./Images/FirstStart.PNG)

We created a simple room. You can run around the room using `WASD` and rotate the camera with the mouse.  

Let's take a look at our `LevelStart` method again to see how it corresponds to the created objects:

```C#
void LevelStart()
{
    Env.One(Gr.PrL.CreateNewHouse(), NodesQueries.All, out var area);
    area.Get.Node.AddSymbol(Gr.Sym.LevelStartMarker);
}
```

The first line refers to the object `Env` of the type `Environment`. This class defines API for creating new buildings. The method `One` tells the framework that we want to create a single new building - the room in which we spawned.

Its first parameter is of the type `ProductionList`. OurFramework uses shape grammars to generate the environment. It is not necessary to know what a shape grammar is, the important part is that it takes a list of production rules which tell it how to create new buildings and place them to already existing environment. Previously in `LevelStart` we used `Gr.PrL.CreateNewHouse()` to get the `ProductionList`. To see what this method does `Ctrl` + `Left mouse button` click on `CreateNewHouse`. 

You should see the following code:

```C#
public ProductionList CreateNewHouse()
{
    return new ProductionList
    (
        pr.CreateNewHouse(2)
    );
}
```

The production list has only 1 rule which adds a new house to the level. The rule is implemented using a special language which we will be covered in the chapter [missing link]. 

The second parameter of `Env.One` is of the type `NodesQuery`. The grammar uses nodes of the type `Node` to represent the created buildings. The environment gets created gradually by sequential application of the rules which create `Node`s.  `NodesQuery` is used to find a set of already created nodes. 

A rule typically requires a previous node, which it uses when adding the new node. The second argument of `Env.One` restricts which nodes can be used by application of the defined production rules. In the case of the production list `Gr.PrL.CreateNewHouse()` the one rule it defines doesn't require any existing nodes. We pass in a `NodesQuery` anyway since it's the part of the API and it might become useful if we change the production list in the future.

The third parameter of the method is an output parameter which returns the newly created building in the variable `var area`. It's type surprisingly isn't `Node`, this type is used by the grammars. For usage in the modules which define gameplay it is wrapped into another type `Area`. This type also remembers the objects which are placed into it.

Usually we want to create multiple rooms rather than a single one. For this reason the output parameter doesn't return a single area, but rather a collection of areas. In the case of `One` the type is `SingleArea` which contains a reference to just one area. Having a collection of a single area might seem strange, but later we will see methods that place stuff into multiple areas and this extra layer simplifies their usage.

The second line of `LevelStart`,
```C#
area.Get.Node.AddSymbol(Gr.Sym.LevelStartMarker);
```
adds a new symbol to the created node. Each node contains symbols, which are used by the production rules to decide where to get applied. The symbol `Gr.Sym.LevelStartMarker` is a special one. It is used to mark the area into which the player and respawning point will be placed automatically by the framework. 

Now that we know how creating environment works, let's create a bit bigger level. We will follow up the initial room with a couple more areas using `Env.Line`. This method appends new area after the last one created so the player has always only one option where to go next. As production list we pick `Gr.PrL.Town()` which defines rules for creating an above ground town connected by wooden bridges. Let's create 5 new areas for now.

We don't put the call directly to `Main`, but rather create a new method `LevelContinue` in which we will customize the environment in the next chapter. The code should look like this:

```C#
...
public void Main()
{
    LevelStart();
    LevelContinue();
}
...
void LevelContinue()
{
    Env.Line(Gr.PrL.Town(), NodesQueries.All, 5, out var line);
}
...
```

Now we can go back to Unity and press play. The initial room should now contain door which can be opened by pressing `E`. 

To better see the environment, we can go back to scene view by pressing `ESC` and then clicking on `Scene` tab at the left right above the scene viewport:

![Scene in scene view](/Images/SceneView.png)

Your scene probably doesn't look the same as the one in the image. The generator applies the production rules randomly which means that every time we run the game we are likely to end up with a very different environment than before. This property is useful for generating unique looking levels that the player can explore, but sometimes we might want to debug something in the same environment.

The entire framework's source of randomness is located in the file `AssetsFolderName\Util\Random.cs`. The first line of the class `MyRandom` defines the random generator responsible for all random numbers:

```C#
static readonly System.Random GlobalRandom = new System.Random();
```

If we want the program to run deterministically, we can just pass it a seed like this: `new System.Random(42)`.

One issue with the created buildings you probably noticed in your own generated level is the lack of roofs. When creating a level we often call multiple methods which create environment. Placing roofs right after every call would remove the opportunity to extend the buildings with more floors in the upcoming calls. For this reason the roofs are placed manually after all other areas are created. 

To create roofs, create another method called `AddRoofs` and call it at the end of `Main`. This time we will use a custom grammar `AllGrammar` that tries to apply rules until no rule can be applied anymore. The production list `Gr.PrL.Roofs()` adds roofs to uncovered rooms which is precisely what we need. We can run general grammar using the method `Env.Execute`. The code should look like this:

```C#
...
public void Main()
{
    LevelStart();
    LevelContinue();
    AddRoofs();
}
...
void AddRoofs()
{
    Env.Execute(new AllGrammar(Gr.PrL.Roofs()));
}
...
```

Once we run the game the buildings finally have roofs:

![Building with roofs](./Images/BuildingsWithRoofs.PNG)

We created a variable environment for our game, but right now it's only good for looking at it. In the upcoming chapters we will define a gameplay to give the player something to play with.

The code for the complete module from this chapter is here:
```C#
using OurFramework.Environment.ShapeGrammar;

namespace OurFramework.LevelDesignLanguage.CustomModules
{
    class TutorialModule : LDLanguage
    {
        public TutorialModule(LanguageParams parameters) : base(parameters) { }

        public void Main()
        {
            LevelStart();
            LevelContinue();
            AddRoofs();
        }

        void LevelStart()
        {
            Env.One(Gr.PrL.CreateNewHouse(), NodesQueries.All, out var area);
            area.Get.Node.AddSymbol(Gr.Sym.LevelStartMarker);
        }

        void LevelContinue()
        {
            Env.Line(Gr.PrL.Town(), NodesQueries.All, 5, out var line);
        }

        void AddRoofs()
        {
            Env.Execute(new AllGrammar(Gr.PrL.Roofs()));
        }
    }
}
```

## Adding enemies and loot

In this chapter we will add enemies and interactive objects to the level we created in the last chapter.

Let's start with the enemies. Add the following code to the method `LevelContinue`:

```C#
var firstArea = line.AreasList.First();
firstArea.AddEnemy(Lib.Enemies.MayanSwordsman());
```

The call `Lib.Enemies.MayanSwordsman()` creates a new swordsman which is added to the first area of our linear environment using `AddEnemy`. When you start the game, you should see a swordsman in the area next to the starting one:

![Enemy attacking the player](./Images/Enemy.PNG)

He moves towards you and tries to attack you. You can attack it too by pressing the `Left mouse button`. If you remove all of his will (indicated by the red line), he will die and disappear. You maybe noticed that the same isn't true for the player. The player can't die, because we didn't define how dying works yet. To do it let's go back to our module and add a method called `CustomizePlayer`. In this method we will add the handler of the player's death the following way:

```C#
void CustomizePlayer(){
    var playerState = State.World.PlayerState;
    playerState
        .AddOnDeath(() =>
        {
            GameObject.Destroy(playerState.Agent.gameObject);
            State.GC.ResetLevel(5.0f);
        });
}
```

We retrieve the player's state from the from `State.World` which contains a reference to it. Then we call the `AddOnDeath` method which adds a callback that will be used when the player's health drops to at most 0. 

Most of the objects in the game contain two kinds of states - a persistent state which remains after the world is reset and a temporary physical state mainly connected to visualization of the object and its interaction with other objects such as checking collision checking. Physical objects get created based on parameters of persistent objects, when the world starts or is reset, and are destroyed once the world is reset. 

In this case `playerState` is a persistent object that defines properties of the player during the entire game. The object `playerState.Agent` is the physical temporary that will be created anew once the world is reset so we have to destroy it by calling `GameObject.Destroy`. We also need to reset the level by calling `ResetLevel` of the object `State.GC`. Now let's call `CustomizePlayer` from `Main`

```C#
...
public void Main()
{
    ...
    CustomizePlayer();
}
...
```

and the main character's death should restart the level return him back to the starting room.

Now that we can die, let's add more enemies instead of only one. We can add enemies by using `ForEach` the following way:

```C#
line.AreasList.ForEach(area =>
    {
        area.AddEnemy(Lib.Enemies.MayanSwordsman());
    });
```

By running through the created areas, you can see that the enemies were indeed created. If you go to the scene view instead of the game, you will might not see all the enemies. Having all the enemies active at the same time would be quite costly so only the enemies in the areas nearby to the player are active.

If we want to place random number of enemies, we can use uniform distribution `UniformDistr`:

```C#
line.AreasList.ForEach(area =>
    {
        Enumerable.Range(0, new UniformDistr(1, 4).Sample()).ForEach(
            _ => area.AddEnemy(Lib.Enemies.MayanSwordsman()));
    });
```

This way of placing enemies is quite verbose. Writing it every time we create a new environment would make the code less readable and more error prone so let's use an object that will do it for us. We can create this object by calling `PlC.RandomAreaPlacer`

```C#
var placer = PlC.RandomAreaPlacer(new UniformDistr(1, 2), Lib.Enemies.MayanSwordsman);
```

and then use it on the desired environment with `Place`: 

```C#
placer.Place(line);
```

We can customize the enemies by changing their weapons or giving them other equipment. Let's give the enemies katanas and wrist rings:

```C#
var placer = PlC.RandomAreaPlacer(
    new UniformDistr(1, 4), 
    () => Lib.Enemies.MayanSwordsman()
        .SetLeftWeapon(Lib.Items.Katana())
        .AddAndEquipItem(Lib.Items.Nails())
        .AddAndEquipItem(Lib.Items.Nails()));
```

When customizing enemies we might also want to change some of their properties such as number of hit points, damage or speed. These are defined by the class `CharacterStats` which defines many stats influencing parameters of the corresponding `CharacterState`. Each stat can be between 0 and 99 and each combination of stat values produces a valid enemy so we can create a wide range of different enemies. Let's modify some stats of our current enemies:

```C#
var placer = PlC.RandomAreaPlacer(
        ...
        .AddAndEquipItem(Lib.Items.Nails())
        .SetStats(
            new CharacterStats() 
            { 
                Will = 10,
                Endurance = 10,
                Agility = 25
            })
        );
```

The enemies we created are quite strong now so let's increase the power of our main character too. Let's extend our `CustomizePlayer` method:

```C#
void CustomizePlayer()
{
    ...
    playerState
        .SetStats(new CharacterStats()
        {
            Agility = 10,
            Strength = 10,
        });
}
```

Now we have enough damage to defeat such high health enemies, but we still can't regenerate health. It could be interesting to let our weapon heal us with every successful strike. To achieve this, we can just create a new weapon and add it a new effect on strike:

```C#
playerState
    .SetStats(...)
    .SetRightWeapon(
        Lib.Items.SculptureClub()
            .AddUpgradeEffect(
            user => enemy =>
            {
                Lib.Effects.Heal(10)(user);
            }));
```

 Weapons have two types of effects: base effects that are added to the weapon right after its created and upgrade effects that can further extend the weapon later. Both of these effects are applied on hitting an enemy. `Lib.Effects` defines the common `Effect`s that can modify `CharacterState`. In this case we heal the `user` of the club after hitting `enemy`.

### Adding loot

The player might also want to heal in preparation for upcoming combat. Let's create a new method that creates a health potion, which we will later put into the inventory:

```C#
public ItemState HealthPotion()
{
    return Lib.Items.NewItem("Health potion", "Heals over time.")
        .OnUse(Lib.Effects.RegenerateHealth(2f, 5f))
        .SetStackable();
}
```

We created a new `ItemState` using `Lib.Items.NewItem` and gave it a name and a description. 

The main purpose of items is to be used by the player. What happens when an item is used is defined by the method `OnUse`, which takes the `Effect` to apply to the user as its parameter. The health regenerating is of the type `Effect` so we can pass it in directly instead of calling it inside a new lambda function. 

By default each new item gets put into its own slot in the inventory. We would like the health potions to stack in one slot, which can be done by calling `SetStackable`. 

A new health potion can be added to the inventory the following way:

```C#
void CustomizePlayer()
{
    ...

    State.World.PlayerState.AddItem(HealthPotion());
}
```

If you now run the game and press `T` to open the inventory, you should see a new health potion:

![Inventory with a health potion](./Images/InventoryHealthPotion.PNG)

You can move the cursor to by `X`/`Z` and equip it to an active slot by `E`:

![Inventory with the health potion in active slot](./Images/InventoryUsingHealthPotion.PNG)

Once you close the inventory with `T` you can use the health potion by pressing `R`:

![Player fighting right after using the health potion](./Images/HealthPotionUsed.PNG)

If you got lucky, the health potion might have appeared in your inventory twice. Every time the generator runs the `DeclareGame` method of the main module is called. The shape grammar generator uses a greedy search to create the environment. The search can fail sometimes and the `DeclareGame` can be called multiple times, which results in 

```C#
State.World.PlayerState.AddItem(HealthPotion()); 
```

adding multiple items to the inventory, because the player's state is one persistent object over the entire game unlike the world, which exists only inside of one level. Adding items directly to inventory is ok for debugging them, but in the final game it's better to let the player retrieve the items from the environment.

Placing items to the level is as simple as placing enemies:

```C#
void LevelContinue()
{
    ...

    var itemPlacer = PlO.RandomAreasPlacer(
        new UniformDistr(3, 6), () => 
        Lib.InteractiveObjects.Item(HealthPotion())
        );
    itemPlacer.Place(line);
}
```

Items can't be placed to the environment directly - they have to be wrapped inside of an interactive object. The player will come to the object and press `E` to put the item to the inventory. The object with this behavior is created by `Lib.InteractiveObjects.Item`.

This time we don't use the placer `PlO.RandomAreasPlacer` which places the generated number of objects across all the areas so some areas might have multiple objects and some might have none. The level with added items looks like this:

![Level with generated items](./Images/LevelWithItems.PNG)

Interactive objects are quite general. They can be used for other purposes than just placing items. Let's create a simple object that will allow us to increase our character's stats. We will put this object into a separate area. The area will be created right after calling the `LevelStart` so that we can immediately go to it when the new game is started.

```C#
public void Main()
{
    LevelStart();
    LevelUpArea();
    LevelContinue();
    ...
}

...

void LevelUpArea()
{
    Env.One(Gr.PrL.Garden(), NodesQueries.All, out var kilnArea);

    var kiln = Lib.InteractiveObjects.Kiln()
            .SetInteraction(ins => ins
                .Say("I am a levelling up kiln.")
                .Interact("Do you want to level up?", 
                    (kiln, player) =>
                    {
                        CharacterStats.StatIncreases.ForEach(statIncrease => 
                            statIncrease.Manipulate(player.Stats));
                    })
            );
    kilnArea.AreasList.First().AddInteractiveObject(kiln);
}
```

If you run the game and enter the area with the kiln you should be able to level up:

![The player standing next to a levelling up kiln](./Images/LevellingUp.PNG)

Now let's look at the code. First we created a new interactive object with the method `Lib.InteractiveObjects.Kiln` and then defined custom interaction with `SetInteraction`. This method provides us with a new `InteractionSequence` and wants us to change it. `InteractionSequence` comes with the following useful methods for adding new states:

* `Say` - prints a text and let's the player go to the next state.
* `Interact` - the player can take an action defined by the callback.
* `Decide` - same as interact, but multiple alternate actions are presented.

In our example we use `Say` to introduce the object and `Interact` to let the player level up. When levelling up, we want to increase every stat by 1. We could write all of the incrementing manually for each stat, but to make it less tedious we use `CharacterStats.StatIncreases`, which returns an array of `StatManipulation`, one for each stat. The class defines an enum corresponding to its stat and action it can apply to the stat, in this case it's an increase by 1. We invoke the increasing actions by calling `Manipulate` for each stat.

The way we defined the interaction allows the player to level up multiple times. We might want to limit the player to only one level up each level. To do this, we can simply set a new interaction sequence once the player levels up. We can also make levelling up fancier by a nice animation played after calling `BurstFire` on the physical object of the kiln. 

```C#
...
(kiln, player) =>
{
    CharacterStats.StatIncreases.ForEach(statIncrease => statIncrease.Manipulate(player.Stats));
    kiln.SetInteraction(ins => ins.Say("Levelled up."));
    kiln.IntObj.BurstFire();
})
...
```

Levelling up is now possible only once each level thanks to the the state of the kiln persisting after player's death.

The code for the module at the end of this chapter is here:

```C#
using OurFramework.Environment.ShapeGrammar;
using System.Linq;
using ContentGeneration.Assets.UI.Model;
using UnityEngine;
using Util;

namespace OurFramework.LevelDesignLanguage.CustomModules
{
    class TutorialModule2 : LDLanguage
    {
        public TutorialModule2(LanguageParams parameters) : base(parameters) { }

        public void Main()
        {
            LevelStart();
            LevelUpArea();
            LevelContinue();
            AddRoofs();

            CustomizePlayer();
        }

        void LevelStart()
        {
            Env.One(Gr.PrL.CreateNewHouse(), NodesQueries.All, out var area);
            area.Get.Node.AddSymbol(Gr.Sym.LevelStartMarker);
        }

        void LevelContinue()
        {
            Env.Line(Gr.PrL.Town(), NodesQueries.All, 5, out var line);

            var placer = PlC.RandomAreaPlacer(
                new UniformDistr(1, 4),
                () => Lib.Enemies.MayanSwordsman()
                    .SetLeftWeapon(Lib.Items.Katana())
                    .AddAndEquipItem(Lib.Items.Nails())
                    .AddAndEquipItem(Lib.Items.Nails())
                    .SetStats(
                     new CharacterStats()
                     {
                         Will = 10,
                         Endurance = 10,
                         Agility = 25
                     })
                    );

            placer.Place(line);

            var itemPlacer = PlO.RandomAreasPlacer(
                new UniformDistr(3, 6), 
                () => Lib.InteractiveObjects.Item(HealthPotion())
                );
            itemPlacer.Place(line);

        }

        void AddRoofs()
        {
            Env.Execute(new AllGrammar(Gr.PrL.Roofs()));
        }

        void CustomizePlayer()
        {
            var playerState = State.World.PlayerState;
            playerState
                .AddOnDeath(() =>
                {
                    GameObject.Destroy(playerState.Agent.gameObject);
                    State.GC.ResetLevel(5.0f);
                });

            playerState
                .SetStats(new CharacterStats()
                {
                    Agility = 10,
                    Strength = 10,
                })
                .SetRightWeapon(
                    Lib.Items.SculptureClub()
                        .AddUpgradeEffect(
                        user => enemy =>
                        {
                            Lib.Effects.Heal(10)(user);
                        }));

            State.World.PlayerState.AddItem(HealthPotion());
        }

        public ItemState HealthPotion()
        {
            return Lib.Items.NewItem("Health potion", "Heals over time.")
                .OnUse(Lib.Effects.RegenerateHealth(2f, 5f))
                .SetStackable();
        }

        void LevelUpArea()
        {
            Env.One(Gr.PrL.Garden(), NodesQueries.All, out var kilnArea);

            var kiln = Lib.InteractiveObjects.Kiln()
                    .SetInteraction(ins => ins
                        .Say("I am a levelling up kiln.")
                        .Interact("Do you want to level up?",
                            (kiln, player) =>
                            {
                                CharacterStats.StatIncreases.ForEach(
                                    statIncrease => statIncrease.Manipulate(player.Stats));
                                kiln.SetInteraction(ins => ins.Say("Levelled up."));
                                kiln.IntObj.BurstFire();
                            })
                    );
            kilnArea.AreasList.First().AddInteractiveObject(kiln);
        }
    }
}
```

# A roguelite game

In previous chapters we created a procedural level by a single event call from the main module. In this chapter we will extend it to a full multilevel roguelite game and add a couple of advanced mechanics.

## Level constructor events

When a new level is started, a bunch of level constructor events are called. The event that starts our current game is declared in the method `DeclareGame` of `MainModule`:

```C#
public void DeclareGame()
{
    State.LC.AddNecessaryEvent($"Tutorial module", 100, level => M.TutorialModule.Main());
}
```

All events that will happen during construction of level are stored in `LevelConstructor` accessible by `State.LC`. The variable `State` corresponds only to the state of the current level while `LevelConstructor` keeps events during the entire game. All existing events are handled at the start of each level. 

New events are added by the method `State.LC.AddNecessaryEvent`. Each event has a priority, the higher the priority the earlier it will be handled by the callback passed as the third parameter. It's also possible to specify an optional parameter `persistent`, which decides if the event should stay in `LevelConstructor` once it was handled.

With all this knowledge we can now create our own events in our module. First let's create a new method `DeclareGame` inside of our module and move the event declaration to it:

```C#
class TutorialModule : LDLanguage
{
    ...
    public void DeclareGame()
    {
        State.LC.AddNecessaryEvent("Main", 100, level => Main());
    } 
    ...
}
```

Then we just replace the body of the original `DeclareGame` with our new method:

```C#
class MainModule : LDLanguage
{
    ...
    public void DeclareGame()
    {
        M.TutorialModule.DeclareGame();
    }
    ...
}
```

The game should now still run the same way as before.

Before we extend our game to contain multiple levels, let's tidy up the module a bit. The player should get initialized only at the start of the game so that the state from previous level is preserved. One exception is handling death - the way the player's death is handled is reset at the start of every level so we need to create an event that re-adds it. 

We also might want to create buildings in other events than the `Start` one. To make sure that all of them have roofs, let's create a separate event for roofs.

Some of the functionality we implemented already exists in other modules, so let's use it. We can remove the following methods:

* `CustomizePlayer` - can be replaced with `M.DeathModule.DieClasically` and a new method `InitializePlayer` which handles the stats and items,
* `LevelStart` - can be replace with `M.LevelModule.LevelStart`,
* `AddRoofs` - can be replace with `M.LevelModule.AddRoofs`.

The entire module after all the changes should now look like this:

```C#
using OurFramework.Environment.ShapeGrammar;
using System.Linq;
using ContentGeneration.Assets.UI.Model;
using UnityEngine;
using Util;
using System;

namespace OurFramework.LevelDesignLanguage.CustomModules
{
    class TutorialModule : LDLanguage
    {
        public TutorialModule(LanguageParams parameters) : base(parameters) { }
        
        public void DeclareGame()
        {
            State.LC.AddNecessaryEvent($"Level Start", 100, level => M.LevelModule.LevelStart(), true);
            State.LC.AddNecessaryEvent("Main", 95, _ => Main(), true);
            State.LC.AddNecessaryEvent("Player initialization", 90, _ => InitializePlayer());
            State.LC.AddNecessaryEvent("Enable death", 90, _ => M.DeathModule.DieClasically(), true);
            State.LC.AddNecessaryEvent("Roofs", -1, _ => M.LevelModule.AddRoofs(), true);
            State.LC.AddNecessaryEvent("End", 99, _ => M.LevelModule.LevelEnd());
        }

        public void Main()
        {
            LevelUpArea();
            LevelContinue();
        }

        void LevelContinue()
        {
            Env.Line(Gr.PrL.Town(), NodesQueries.All, 5, out var line);
            
            var placer = PlC.RandomAreaPlacer(
                new UniformDistr(1, 4), 
                () => Lib.Enemies.MayanSwordsman()
                    .SetLeftWeapon(Lib.Items.Katana())
                    .AddAndEquipItem(Lib.Items.Nails())
                    .AddAndEquipItem(Lib.Items.Nails())
                    .SetStats(
                     new CharacterStats() 
                     { 
                         Will = 10,
                         Endurance = 10,
                         Agility = 25
                     })
                    );
            
            placer.Place(line);

            var itemPlacer = PlO.RandomAreasPlacer(new UniformDistr(3, 6), () => Lib.InteractiveObjects.Item(HealthPotion()));
            itemPlacer.Place(line);
            
        }

        void InitializePlayer()
        {
            var playerState = State.World.PlayerState;
            playerState
                .SetStats(new CharacterStats()
                {
                    Agility = 10,
                    Strength = 10,
                })
                .SetRightWeapon(
                    Lib.Items.SculptureClub()
                        .AddUpgradeEffect(
                        user => enemy =>
                        {
                            Lib.Effects.Heal(10)(user);
                        }));
        }

        public ItemState HealthPotion()
        {
            return Lib.Items.NewItem("Health potion", "Heals over time.")
                .OnUse(Lib.Effects.RegenerateHealth(2f, 5f))
                .SetStackable();
        }

        void LevelUpArea()
        {
            Env.One(Gr.PrL.Garden(), NodesQueries.All, out var kilnArea);

            var kiln = Lib.InteractiveObjects.Kiln()
                    .SetInteraction(ins => ins
                        .Say("I am a levelling up kiln.")
                        .Interact("Do you want to level up?", 
                            (kiln, player) =>
                            {
                                CharacterStats.StatIncreases.ForEach(statIncrease => statIncrease.Manipulate(player.Stats));
                                kiln.SetInteraction(ins => ins.Say("Levelled up."));
                                kiln.IntObj.BurstFire();
                            })
                    );
            kilnArea.AreasList.First().AddInteractiveObject(kiln);
        }
    }
}


```

Notice that we used priorities to order the events the way that we want, start happening at the begining, roofs are added at the end. It might seem like just ordering the calls to the `State.LC.AddNecessaryEvent` would be a simpler way to write it, but events can be also added dynamically once the game begins and priorities help us with executing them at the right time. The values of priorities can be arbitrary, we chose to have them in the range between -1 and 100.

Our game now works the same way as before, the only thing we are still missing is a way to get to the next level. For this we will use ` M.LevelModule.LevelEnd` which adds an area with an object that starts the next level. This object is not special in any way, it just calls the method `State.GC.GoToNextLevel` that handles everything needed to start the next level. Let's add it using an event:

```C#
public void DeclareGame()
{
    ...
    State.LC.AddNecessaryEvent("End", 99, _ => M.LevelModule.LevelEnd(), true);
}
```

Once we run the game, the following object transporting us to next level should be in some room:

![Player standing next to transporter](./Images/Transporter.PNG)

Using an event that happens right after the `Start Level` event spawns the transporter next to the starting area which can be used for debugging, but to make the game more challenging we might want to put the transporter at the end of the environment we created with `Main` instead. We can do that in the following way:

```C#
...
void LevelContinue()
{
    ...
    
    var end = line.LastArea();
    end.AddInteractiveObject(
        Lib.InteractiveObjects.Transporter(State.GC)
        );
}
...
```

Once we go to the next level, we get completely new environment with different positions of items and enemies, but because the level was generated using the same grammar and enemies, it might feel the same as the first one. Varying the grammar and enemies is one way to fix this problem, but there are other ways to make the progress visible to the player. 

We can change lighting and environment map to make the level feel different. For this purpose we can use the module `M.EnvironmentModule`, which can create both depending on the current level with its method `CreateSky`. To create environment map each level we need to add the following event:

```C#
public void DeclareGame()
{
    ...
    State.LC.AddNecessaryEvent($"Sky", 0, level => M.EnvironmentModule.CreateSky(level), true);
}
```

If you've done everything correctly, you should see sky and sea:

![Sky and sea observed by the player](./Images/EnvironmentMap.PNG)

The sky and the sea aren't an actual Unity environment map, but rather a geometry so that its texture can be manipulated using Universal Rendering Pipeline. 

If you want to see how the environment map changes each level, you can use method `M.EnvironmentModule.TestSky`, which creates an area with an NPC that gives sky changing items.

So far we only created events that necessarily happen when the level is started. If many such events are added, the level might get too big and we might run into performance issues. But we also want to create many modules and not limit them in how large part of the level they can create. To solve this issue, the method `State.LC.AddPossibleEvent` exists. Only few events added this way will be executed at the start of each level, allowing us to use as many of these events as we want without any problem.

Let's test this by creating randomized NPCs. Each NPC will have a random name, a place it comes from and an item it sells. To create the NPCs we can use the following method:

```C#
IEnumerable<InteractiveObjectState> RandomNPCs()
{
    var names = new[] { "Amanda", "Bolton", "Coffey", "Darcie" };
    var places = new[] { "America", "Azeroth", "Moon" };
    var itemFs = Lib.Items.AllHeadItems();

    return 
        names.SelectMany(name =>
        places.SelectMany(place =>
        itemFs.Select(itemF =>
        {
            var item = itemF();
            int price = 100;
            return Lib.InteractiveObjects.Farmer()
                    .SetInteraction(ins => ins
                        .Say($"My greetings, I'm {name} and I come from {place}")
                        .Decide($"May I offer you a {item.Name}?",
                            opt => opt
                                .SetDescription($"Yes (pay {price} spirit)")
                                .SetAction(
                                    (npc, player) =>
                                    {
                                        if (player.Pay(price))
                                        {
                                            player.AddItem(item);
                                            npc.SetInteraction(ins => ins.Say("I wish you luck on your journey."));
                                        }
                                        else
                                        {
                                            Msg.Show("Not enough spirit");
                                        }
                                    }),
                            opt => opt
                                .SetDescription($"No")
                                .SetAction(
                                    (npc, player) =>
                                    {
                                        npc.Interaction.TryMoveNext(npc);
                                    })
                            )
                        .Say("Ok, fine, bye.")
                    );
        })));
}
```

For each NPC in the collection we create a new possible event this way:

```C#
void AddNpcEvents()
{
    RandomNPCs().Shuffle().ForEach(npc =>
    {
        State.LC.AddPossibleEvent("Npc", 50, _ =>
        {
            Env.One(Gr.PrL.Town(), NodesQueries.All, out var npcArea);
            npcArea.Get.AddInteractiveObject(npc);
        });
    });
}
```

It remains to call `AddNpcEvents` from `DeclareGame` and few areas with NPCs will spawn in each level:

![Player interacting with an NPC](./Images/InteractingWithNPC.PNG)

Note that this is more of an extreme way how to use possible events. Typically each module should declare only a few such events so that everyone gets a chance to be run.

The full code of the module from this chapter is here:

```C#
using OurFramework.Environment.ShapeGrammar;
using System.Linq;
using ContentGeneration.Assets.UI.Model;
using UnityEngine;
using Util;
using System;
using System.Collections.Generic;
using ContentGeneration.Assets.UI;

namespace OurFramework.LevelDesignLanguage.CustomModules
{
    class TutorialModule : LDLanguage
    {
        public TutorialModule(LanguageParams parameters) : base(parameters) { }
        
        public void DeclareGame()
        {
            State.LC.AddNecessaryEvent($"Level Start", 100, level => M.LevelModule.LevelStart(), true);
            State.LC.AddNecessaryEvent("Main", 95, _ => Main(), true);
            State.LC.AddNecessaryEvent("Player initialization", 90, _ => InitializePlayer());
            State.LC.AddNecessaryEvent("Enable death", 90, _ => M.DeathModule.DieClasically(), true);
            State.LC.AddNecessaryEvent("Roofs", -1, _ => M.LevelModule.AddRoofs(), true);
            State.LC.AddNecessaryEvent($"Sky", 0, level => M.EnvironmentModule.CreateSky(level), true);

            AddNpcEvents();
        }

        public void Main()
        {
            LevelUpArea();
            LevelContinue();
        }

        void LevelContinue()
        {
            Env.Line(Gr.PrL.Town(), NodesQueries.All, 5, out var line);
            
            var placer = PlC.RandomAreaPlacer(
                new UniformDistr(1, 4), 
                () => Lib.Enemies.MayanSwordsman()
                    .SetLeftWeapon(Lib.Items.Katana())
                    .AddAndEquipItem(Lib.Items.Nails())
                    .AddAndEquipItem(Lib.Items.Nails())
                    .SetStats(
                     new CharacterStats() 
                     { 
                         Will = 10,
                         Endurance = 10,
                         Agility = 25
                     })
                    );
            
            placer.Place(line);

            var itemPlacer = PlO.RandomAreasPlacer(new UniformDistr(3, 6), () => Lib.InteractiveObjects.Item(HealthPotion()));
            itemPlacer.Place(line);


            var end = line.LastArea();
            end.AddInteractiveObject(
                Lib.InteractiveObjects.Transporter(State.GC)
                );
        }

        void InitializePlayer()
        {
            var playerState = State.World.PlayerState;
            playerState
                .SetStats(new CharacterStats()
                {
                    Agility = 10,
                    Strength = 10,
                })
                .SetRightWeapon(
                    Lib.Items.SculptureClub()
                        .AddUpgradeEffect(
                        user => enemy =>
                        {
                            Lib.Effects.Heal(10)(user);
                        }));
        }

        public ItemState HealthPotion()
        {
            return Lib.Items.NewItem("Health potion", "Heals over time.")
                .OnUse(Lib.Effects.RegenerateHealth(2f, 5f))
                .SetStackable();
        }

        void LevelUpArea()
        {
            Env.One(Gr.PrL.Garden(), NodesQueries.All, out var kilnArea);

            var kiln = Lib.InteractiveObjects.Kiln()
                    .SetInteraction(ins => ins
                        .Say("I am a levelling up kiln.")
                        .Interact("Do you want to level up?", 
                            (kiln, player) =>
                            {
                                CharacterStats.StatIncreases.ForEach(statIncrease => statIncrease.Manipulate(player.Stats));
                                kiln.SetInteraction(ins => ins.Say("Levelled up."));
                                kiln.IntObj.BurstFire();
                            })
                    );
            kilnArea.AreasList.First().AddInteractiveObject(kiln);
        }

        void AddNpcEvents()
        {
            RandomNPCs().Shuffle().ForEach(npc =>
            {
                State.LC.AddPossibleEvent("Npc", 50, _ =>
                {
                    Env.One(Gr.PrL.Town(), NodesQueries.All, out var npcArea);
                    npcArea.Get.AddInteractiveObject(npc);
                });
            });
        }

        IEnumerable<InteractiveObjectState> RandomNPCs()
        {
            var names = new[] { "Amanda", "Bolton", "Coffey", "Darcie" };
            var places = new[] { "America", "Azeroth", "Moon" };
            var itemFs = Lib.Items.AllHeadItems();

            return 
                names.SelectMany(name =>
                places.SelectMany(place =>
                itemFs.Select(itemF =>
                {
                    var item = itemF();
                    int price = 100;
                    return Lib.InteractiveObjects.Farmer()
                            .SetInteraction(ins => ins
                                .Say($"My greetings, I'm {name} and I come from {place}")
                                .Decide($"May I offer you a {item.Name}?",
                                    opt => opt
                                        .SetDescription($"Yes (pay {price} spirit)")
                                        .SetAction(
                                            (npc, player) =>
                                            {
                                                if (player.Pay(price))
                                                {
                                                    player.AddItem(item);
                                                    npc.SetInteraction(ins => ins.Say("I wish you luck on your journey."));
                                                }
                                                else
                                                {
                                                    Msg.Show("Not enough spirit");
                                                }
                                            }),
                                    opt => opt
                                        .SetDescription($"No")
                                        .SetAction(
                                            (npc, player) =>
                                            {
                                                npc.Interaction.TryMoveNext(npc);
                                            })
                                    )
                                .Say("Ok, fine, bye.")
                            );
                })));
        }
    }
}
```

## Quest

In this chapter we will create a quest that runs over multiple levels. Before we begin, let's comment out the call to `AddNpcEvents` so that we can play our new quest:

```C#
public void DeclareGame()
{
    ...
    //AddNpcEvents();
}
```

Let's make a quest about awakening a powerful dragon. It will be a side quest completable during 3 consecutive levels. The player will be able to progress the quest by picking up and using items. For each level we will create a separate method:

```C#
void StartQuest()
{
    // Create an environment with an item that starts the quest
    Env.One(Gr.PrL.Town(), NodesQueries.All, out var area);
    var questStarter = Lib.Items.NewItem("Dragon Egg", "Crack to unleash a dragon.")
        .SetConsumable()
        .OnUse(ch => {
            Msg.Show("A dragon has been unleashed.");
            State.LC.AddPossibleEvent("Dragon quest", 50,
                        level =>ContinueQuest());
        });
    area.Get.AddInteractiveObject(Lib.InteractiveObjects.Item(questStarter));
}

void ContinueQuest()
{
    Env.One(Gr.PrL.Town(), NodesQueries.All, out var area);

    // Continue the quest
    var questContinuer = Lib.Items.NewItem("Dragon Scale", "Caressing dragon scales brings luck.")
            .SetConsumable()
            .OnUse(ch =>
            {
                Msg.Show("The dragon grows.");
                State.LC.AddPossibleEvent("Dragon quest 2", 50,
                        level => EndQuest());
            });
    area.Get.AddInteractiveObject(Lib.InteractiveObjects.Item(questContinuer));

}

void EndQuest()
{
    Env.One(Gr.PrL.Town(), NodesQueries.All, out var area);
}
```

To make the quest more interesting, let's add more complex environment to the second part:

```C#
void ContinueQuest()
{
    // Create a locked room and a path to its key
    M.LockingModule.LineWithKey(NodesQueries.All, 4, Gr.PrL.Garden(), out var locked, out var keyLine);

    // Place enemies
    var enemyPlacer = PlC.RandomAreaPlacer(new UniformDistr(1, 3), Enemies());
    enemyPlacer.Place(keyLine);

    // Continue the quest
    var questContinuer = Lib.Items.NewItem("Dragon Scale", "Caressing dragon scales brings luck.")
            .SetConsumable()
            .OnUse(ch =>
            {
                Msg.Show("The dragon grows.");
                State.LC.AddPossibleEvent("Dragon quest 2", 50,
                level => EndQuest());
            });
    locked.Get.AddInteractiveObject(Lib.InteractiveObjects.Item(questContinuer));

}

Func<CharacterState>[] Enemies()
{
    return new Func<CharacterState>[]
        {
        Lib.Enemies.MayanSwordsman,
        Lib.Enemies.MayanThrower,
        Lib.Enemies.SkinnyWoman,
        };
}
```

We used the method `M.LockingModule.LineWithKey` which works the same way as the linear grammar we've seen before, but it locks the final area `locked` and places key at the end of `keyLine`. We also added some enemies to make the quest more challenging. Speaking of challenge let's add the final boss of this quest - a powerful dragon with a lot of hit points:

```C#
void EndQuest()
{
    // Place the powerful dragon to the level
    Env.One(Gr.PrL.Town(), NodesQueries.All, out var area);
    var dragon = Lib.Enemies.DragonMan();
    dragon
        .DropItem(
            () => Lib.InteractiveObjects.Item(
                Lib.Items.NewItem("Dragons Demise", "The dragon fades, but its Will lives on.")
                    .OnUse(ch => ch.Stats.Will += 5))
        );
    dragon.Stats.Will = 40;
    area.Get.AddEnemy(dragon);
}
```

Fighting an enemy with so much hit points can be a bit challenging for some players. We might consider adding an option to simplify the fight. Reducing the dragon's Will if player defeats another bunch of enemies seems like a good choice:

```C#
void EndQuest()
{
    ...

    // Weaken the dragon using an interactive object
    Env.Line(Gr.PrL.Castle(), NodesQueries.All, 4, out var pathToGoblet);
    var goblet = Lib.InteractiveObjects.SpikyGoblet()
        .SetInteraction(ins => ins
            .Interact("Touch", (goblet, player) =>
            {
                dragon.Stats.Will = 10;
                Msg.Show("Dragon weakened");
                goblet.SetInteraction(ins => ins.Say("Dragon weakened"));
            })
        );
    pathToGoblet.LastArea().AddInteractiveObject(goblet);
    
    // Place enemies
    var enemyPlacer = PlC.RandomAreaPlacer(new UniformDistr(1, 3), Enemies());
    enemyPlacer.Place(pathToGoblet);
}
```

When character's stat is set, its real attributes are automatically adjusted so reducing the dragon's Will also reduces its hit points.

It could also be interesting to give the player an option to defeat the dragon easily at some greater cost - for example losing some stats. Let's create a sword that reduces the player's Will with each swing against the dragon, but deals a huge damage to it:

```C#
void EndQuest()
{
    ...

    // Deal large damage to dragon using a strong sword
    var powerSword = Lib.Items.MayanSword()
        .AddUpgradeEffect(
        user => enemy =>
        {
            if (enemy == dragon && user.Stats.Will > 0)
            {
                Lib.Effects.Damage(new DamageDealt(DamageType.Chaos, 100))(enemy);
                user.Stats.Will--;
            }
        })
        .SetName("Dragon Slayer")
        .SetDescription("A powerful weapon whose mission is to slay its chosen dragon. Only those who posses enough Will are fit to carry it and even then it takes its toll.");
    area.Get.AddInteractiveObject(Lib.InteractiveObjects.Item(powerSword));
}
```

When an enemy is successfuly hit with the sword it checks if the enemy is the dragon and if so it deals large damage to it as promised. Putting the sword in the dragon's area works, but it could be more interesting to introduce it to the player earlier to foreshadow the upcoming fight.
But we can't currently do that in the any of the previous parts of the quest, because we don't have the reference to `dragon` yet. 

There is a simple fix to this problem, we can introduce the variable `dragon` in an earlier method and then just pass it to the `EndQuest` method and only then create its physical representation. It might also seem like a good idea to create a data member of our module to store the dragon's value between calls, but modules are assumed to be stateless so passing it as parameter is a cleaner solution.

```C#
void ContinueQuest()
{
    // Create a locked room and a path to its key
    M.LockingModule.LineWithKey(NodesQueries.All, 4, Gr.PrL.Garden(), out var locked, out var keyLine);

    // Place enemies
    var enemyPlacer = PlC.RandomAreaPlacer(new UniformDistr(1, 3), Enemies());
    enemyPlacer.Place(keyLine);

    // Create dragon state so that we can use it when defining sword that defeats it
    var dragon = Lib.Enemies.DragonMan();
    

    // Deal large damage to dragon using a strong sword
    // The dragon whose reference we use doesn't exist physically in this level yet
    var powerSword = Lib.Items.MayanSword()
        .AddUpgradeEffect(
        user => enemy =>
        {
            if (enemy == dragon && user.Stats.Will > 0)
            {
                Lib.Effects.Damage(new DamageDealt(DamageType.Chaos, 100))(enemy);
                user.Stats.Will--;
            }
        })
        .SetName("Dragon Slayer")
        .SetDescription("A powerful weapon whose mission is to slay its chosen dragon. Only those who posses enough Will are fit to carry it and even then it takes its toll.");
    locked.Get.AddInteractiveObject(Lib.InteractiveObjects.Item(powerSword));

    // Continue the quest
    var questContinuer = Lib.Items.NewItem("Dragon Scale", "Caressing dragon scales brings luck.")
            .SetConsumable()
            .OnUse(ch =>
            {
                Msg.Show("The dragon grows.");
                State.LC.AddPossibleEvent("Dragon quest 2", 50,
                level => EndQuest(dragon));// Pass the dragon to the next level
            });
    locked.Get.AddInteractiveObject(Lib.InteractiveObjects.Item(questContinuer));
}

void EndQuest(CharacterState dragon)
{
    ...
}
```

We could also add something for player to play with when progressing through the environment. Spells seem like a great choice. A collection of spells sorted by tiers can be obtained by calling `Lib.SpellItems.AllSpellsByPower`. Tiers go from 0 with only two weak spells up to 3 with a very powerful spells. Let's add tier 1 spells to the second part of the quest and tier 2 to the end.

```C#
void ContinueQuest()
{
    ...

    // Place spell items
    var spellPlacer = PlO.RandomAreasPlacer(new UniformDistr(4, 6), 
        () => Lib.InteractiveObjects.Item(
            Lib.SpellItems.AllSpellsByPower()[1].GetRandom()().SetStackable()));
    spellPlacer.Place(keyLine);
}


void EndQuest(CharacterState dragon)
{
    ...
    
    // Place stronger spell items
    var spellPlacer = PlO.RandomAreasPlacer(new UniformDistr(2, 4),
        () => Lib.InteractiveObjects.Item(
            Lib.SpellItems.AllSpellsByPower()[2].GetRandom()().SetStackable()));
    spellPlacer.Place(pathToGoblet);
}
```

We can create the entire questline with a new possible event:

```C#

public void DeclareGame()
{
    ...

    State.LC.AddPossibleEvent("Quest", 50, _ => StartQuest());
}
```

Don't forget to increase your Will before starting the game to get the damage bonus ;-).

The entire code of the quest is here:

```C#
void StartQuest()
{
    // Create an environment with an item that starts the quest
    Env.One(Gr.PrL.Town(), NodesQueries.All, out var area);
    var questStarter = Lib.Items.NewItem("Dragon Egg", "Crack to unleash a dragon.")
        .SetConsumable()
        .OnUse(ch => {
            Msg.Show("A dragon has been unleashed.");
            State.LC.AddPossibleEvent("Dragon quest", 50,
                level =>ContinueQuest());
        });
    area.Get.AddInteractiveObject(Lib.InteractiveObjects.Item(questStarter));
}

void ContinueQuest()
{
    // Create a locked room and a path to its key
    M.LockingModule.LineWithKey(NodesQueries.All, 4, Gr.PrL.Garden(), out var locked, out var keyLine);

    // Place enemies
    var enemyPlacer = PlC.RandomAreaPlacer(new UniformDistr(1, 3), Enemies());
    enemyPlacer.Place(keyLine);

    
    // Place spell items
    var spellPlacer = PlO.RandomAreasPlacer(new UniformDistr(4, 6), 
        () => Lib.InteractiveObjects.Item(
            Lib.SpellItems.AllSpellsByPower()[1].GetRandom()().SetStackable()));
    spellPlacer.Place(keyLine);

    // Create dragon state so that we can use it when defining sword that defeats it
    var dragon = Lib.Enemies.DragonMan();
    

    // Deal large damage to dragon using a strong sword
    // The dragon whose reference we use doesn't exist physically in this level yet
    var powerSword = Lib.Items.MayanSword()
        .AddUpgradeEffect(
        user => enemy =>
        {
            if (enemy == dragon && user.Stats.Will > 0)
            {
                Lib.Effects.Damage(new DamageDealt(DamageType.Chaos, 100))(enemy);
                user.Stats.Will--;
            }
        })
        .SetName("Dragon Slayer")
        .SetDescription("A powerful weapon whose mission is to slay its chosen dragon. Only those who posses enough Will are fit to carry it and even then it takes its toll.");
    locked.Get.AddInteractiveObject(Lib.InteractiveObjects.Item(powerSword));
    

    // Continue the quest
    var questContinuer = Lib.Items.NewItem("Dragon Scale", "Caressing dragon scales brings luck.")
            .SetConsumable()
            .OnUse(ch =>
            {
                Msg.Show("The dragon grows.");
                State.LC.AddPossibleEvent("Dragon quest 2", 50,
                level => EndQuest(dragon));// Pass the dragon to the next level
            });
    locked.Get.AddInteractiveObject(Lib.InteractiveObjects.Item(questContinuer));

}

Func<CharacterState>[] Enemies()
{
    return new Func<CharacterState>[]
        {
        Lib.Enemies.MayanSwordsman,
        Lib.Enemies.MayanThrower,
        Lib.Enemies.SkinnyWoman,
        };
}

void EndQuest(CharacterState dragon)
{
    // Place the powerful dragon to the level
    Env.One(Gr.PrL.Town(), NodesQueries.All, out var area);
    dragon
        .DropItem(
            () => Lib.InteractiveObjects.Item(
                Lib.Items.NewItem("Dragons Demise", "The dragon fades, but its Will lives on.")
                    .OnUse(ch => ch.Stats.Will += 5))
        );
    dragon.Stats.Will = 40;
    area.Get.AddEnemy(dragon);

    // Weaken the dragon using an interactive object
    Env.Line(Gr.PrL.Castle(), NodesQueries.All, 4, out var pathToGoblet);
    var goblet = Lib.InteractiveObjects.SpikyGoblet()
        .SetInteraction(ins => ins
            .Interact("Touch", (goblet, player) =>
            {
                dragon.Stats.Will = 10;
                Msg.Show("Dragon weakened");
                goblet.SetInteraction(ins => ins.Say("Dragon weakened"));
            })
        );
    pathToGoblet.LastArea().AddInteractiveObject(goblet);
    
    // Place enemies
    var enemyPlacer = PlC.RandomAreaPlacer(new UniformDistr(1, 3), Enemies());
    enemyPlacer.Place(pathToGoblet);
    
    // Place stronger spell items
    var spellPlacer = PlO.RandomAreasPlacer(new UniformDistr(2, 4),
        () => Lib.InteractiveObjects.Item(
            Lib.SpellItems.AllSpellsByPower()[2].GetRandom()().SetStackable()));
    spellPlacer.Place(pathToGoblet);
}
```

## Existing modules

This chapter contains description of all existing modules.

* **Ascending Module**

  Declares Ascending Kiln which allows the player to turn spirit into stats. The module can also create an event that creates an area with a persisting kiln each level.  

* **Death Module**
  
  Introduces various ways how to handle the player's death - restarting level, dropping a bloodstain, ending game... The methods should be called at the start of each level. 

* **Details Module**
  
  Places dead end areas such as balconies, terraces, side towers. The areas contain items that increase spirit and rare items.

* **Environment Module**
  
  Creates sky and sea appropriate for the level.

* **Faction Module**
  
  When initialized creates a number of factions. Each faction has a subset of concepts - enemies, spells, production lists and weapons. Faction creates quests that can be completed over multiple levels. The quests contain only the concepts typical for the faction. 

* **Level Module**
  
  Contains methods that can be useful when starting to create a new level such as start, end, mockup main path...

* **Locking Module**

  Places areas locked behind a door and handles their unlocking.

* **Main Module**

  Contains the dispatch method called when the game is started.

* **Out of Depth Encounters Module**

  Places an area with a powerful enemy. The enemy holds a key to another area with a reward.

* **Testing Module**

  Tests various features of the game such as items, spells, grammars, events...

# Shape grammars

In this part of the tutorial we will implement new grammars using our own production rules.

Let's create the method in which we will be using the grammars. We will create a new method in the `TestingModule` and call it from the main module:

#### **`LevelDesignLanguage\Modules\TestingModule.cs`**
```C#
class TestingModule : LDLanguage
{
    ...

    public void NewGrammar()
    {
    }
}
```
#### **`LevelDesignLanguage\Modules\MainModule.cs`**
```C#
class MainModule : LDLanguage
{
    ...

    public void DeclareGame()
    {
        State.LC.AddNecessaryEvent($"New Grammar", 100, level => M.TestingModule.NewGrammar());
    }

    ...
}
```

Every level has to contain a starting area, so let's start with it so that we can test the grammar. To create a new area, we have to define a production rule that generates it. Production rules are typically declared in the class `Productions` and that is where we will put our rule too:

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
``` C#
public class Productions
{
    ...

    #region NewGrammar

    public Production NewStart()
    {
        return new Production(
            "Place New Start",
            new ProdParamsManager(),
            (state, _) =>
            {
            });
    }

    #endregion
}
```

Productions for different purposes exist in the class `Productions` and to keep it tidy they are organized in regions. We created a new region `NewGrammar` to which all our data will be put. The `Production` we created is not just a variable, but a factory method. This has two purposes. First, `Production` contains some state which is modified when executing the grammar so we need to use a different instances of `Production` in different grammars. And second, we might want to create more general productions which depend on some parameters.

Right now we have declared `Production` with the name `Place New Start`, no previous nodes required to be run and an empty body. We want to create a new room and place it to the level so we have to modify the body: 

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
```C#
(state, _) =>
{
    return state.NewProgram(
        prog => prog
            .Set(() => ldk.les.Room(5, 5, 2)
                .MoveBottomTo(4)
                .GN(sym.FullFloorMarker, sym.LevelStartMarker))
            .PlaceCurrentFrom(state.Root)
        );
}
```

The body returns `ProductionProgram` which defines how to create the new environment and stores operations that will later create it. We start with an empty program obtained by `state.NewProgram` and use the methods `Set` and `PlaceCurrentFrom` to modify it. `ProductionProgram` keeps a list of active `Node`s. A new node is set to the list using `Set`. All nodes currently in the list are placed to the level by using `PlaceCurrentFrom`.

When creating a new `Node` we first have to create its geometry. All geometry consists of cubes and their edges and faces. There are two types of data structures that we use for storing geometry: 

* `CubeGroup` - keeps a list of cubes,
* `LevelElement` - hierarchical, can have either reference to `CubeGroup` or a list of `LevelElement`s. Also defines the style of assets that will be placed to the level.

 The variable `ldk` of the type `LevelDevelopmentKit` provides us with many ways how to create a new geometry. The variable `ldk.les` allows us to create new `LevelElement`s. One such method is `ldk.les.Room` which just creates a box with given extents and styles is as a room. The geometry of both `LevelElement` and `CubeGroup` is immutable. The method `MoveBottomTo` moves the `LevelElement` by creating a new instance of it. 
 
 We can wrap the `LevelElement` into a `Node` by calling `GN` on it. Each `Node` defines symbols which can be used by `Production` and other places in the program to query them. The two symbols which we passed to `GN` have the following purposes:

 * `sym.FullFloorMarker` - other productions can connect to it with a path,
 * `sym.LevelStartMarker` -  we already saw this one in the first chapter, it tells the game where to put the spawning place for the player.

We will be adding more production rules later and relying only on `sym.FullFloorMarker` to coordinate them would be difficult. Let's add another symbol that will better describe what kind of area we created. We have to declare the new symbol in the class `Symbols`:

#### **`ShapeGrammarGenerator\ShapeGrammar\Symbols.cs`**
``` C#
public class Symbols
{
    ...

    #region New symbols

    public Symbol NewRoom { get; } = new Symbol("NewRoom");

    #endregion
}
```

And then place it to the new node declaration:

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
```C#
...
.GN(sym.FullFloorMarker, sym.LevelStartMarker, sym.NewRoom)
...
```

When a new `Node` is placed to the level, it is typically derived from other already existing `Node`. This relationship is captured by the arguments of `PlaceCurrentFrom` which become parents of the currently active nodes. Since our production rule doesn't derive from any `Node`, we have to set the root as the parent. 

With the rule being ready, we can now go and use it in a grammar, but first we have to declare a new `ProductionList` that contains it:

#### **`ShapeGrammarGenerator\ShapeGrammar\ProductionLists.cs`**
``` C#
public class ProductionLists
{
    ...

    public ProductionList NewStart()
    {
        return new ProductionList
        (
            pr.NewStart()
        );
    }
}
```

We only need to invoke the rule at the start of the level. For this purpose the `RandomGrammar` executing only one production will be enough:

#### **`LevelDesignLanguage\Modules\TestingModule.cs`**
``` C#
public void NewGrammar()
{
    Env.Execute(new RandomGrammar(Gr.PrL.NewStart(), 1));
}
```

If everything went correctly, you should see the following output:

![A room floating in the air](./Images/FloatingRoom.PNG)

We have created a new room, but currently it's floating in the air. We should add a foundation to it. We could create a foundation `Node` by taking the `CubeGroup` of all the cubes under the room. Fortunately, a method that does this already exists in `ProductionProgram`, it is called `Found` and it creates a foundation for all the currently active `Node`s. We set the room as the parent of our newly created foundation. We can use `CurrentFirst` to retrive the room from the active `Node`s. The program will now look like this:

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
```C#
return state.NewProgram(
    prog => prog
        .Set(() => ldk.les.Room(5, 5, 2)
            .MoveBottomTo(4)
            .GN(sym.NewRoom, sym.FullFloorMarker, sym.LevelStartMarker))
        .PlaceCurrentFrom(state.Root)

        .CurrentFirst(out var room)
        .Found()
        .PlaceCurrentFrom(room)
        );
```

And this is the resulting environment:

![Room with foundtion](./Images/RoomWithFoundation.PNG)

One more detail which could turn an oridnary room into a full blown house is a roof. Adding foundation immediately is a good idea, because we want to make sure that no other rule will block the space, but other rules might find a way to use the space above our room other than just placing a roof. We still want to make sure that if nobody uses the space above, we can still place the roof. For this reason we create a reservation of the space that can be later used by other productions including the ones that make roofs.

The finished `ProductionProgram` including the reservation looks like this:

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
```C#
return state.NewProgram(
    prog => prog
        .Set(() => ldk.les.Room(5, 5, 2)
            .MoveBottomTo(4)
            .GN(sym.NewRoom, sym.FullFloorMarker, sym.LevelStartMarker))
        .PlaceCurrentFrom(state.Root)

        .CurrentFirst(out var room)
        .Found()
        .PlaceCurrentFrom(room)

        .Set(() => room)
        .ReserveUpward(2, sym.UpwardReservation)
        .PlaceCurrentFrom(room)
        );
```

As we saw before, the roofs need a separate grammar that is executed at the end. Let's create a new production list with a production obtained from an already existing factory method `Roof`, which takes the reservation we made and turns it into roof:


#### **`ShapeGrammarGenerator\ShapeGrammar\ProductionLists.cs`**
``` C#
public class ProductionLists
{
    ...

    public ProductionList NewRoofs()
    {
        return new ProductionList
        (
            pr.Roof(pr.sym.NewRoom, 3, AreaStyles.CrossRoof()),
            pr.Roof(pr.sym.NewRoom, 2, AreaStyles.CrossRoof())
        );
    }
}
```

We added two instances of the production that creates roof, this is because roofs of height 3 are the preferable option, but sometimes the space above could already be blocked by a path for example. To make sure that the roof can be always created, we add another production that takes only what we reserved.

We use `AllGrammar` as before to make sure that all buildings have roofs. `AllGrammar` executes the rules in order in which they appear in the list so the higher roof will be prefered.

#### **`LevelDesignLanguage\Modules\TestingModule.cs`**
``` C#
public void NewGrammar()
{
    Env.Execute(new RandomGrammar(Gr.PrL.NewStart(), 1));
    Env.Execute(new AllGrammar(Gr.PrL.NewRoofs()));
}
```

The room now has a roof:

![Room with a roof](./Images/RoomWithRoof.PNG)

The class `Productions` already contains some predefined general production factories which can be specialized for specific situations. We can implement `NewStart` by using `Place` instead of writing the program manually:


#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
```C#
public Production NewStart()
{
    return Place(
        4, 
        () => ldk.les.Room(5, 5, 2), 
        le => le?.GN(sym.NewRoom, sym.LevelStartMarker, sym.FullFloorMarker), 
        Reserve(2, sym.UpwardReservation));
}
```

Now that the starting room and roofs are out of the way, we can finally focus on our new grammar. Let's start with a simple rule that just adds a room next to an already existing one:

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
```C#
public Production NewRoomNear()
{
    return new Production(
        "New Room Near",
        new ProdParamsManager().AddNodeSymbols(sym.NewRoom),
        (state, pp) =>
        {
            var what = pp.Param;

            return state.NewProgram(prog => prog
                .Set(() => ldk.les.Box(3, 3, 2).SetAreaStyle(AreaStyles.Room()).GN())
                .MoveNearTo(what, 1)
                .Change(node => node.LE.GN(sym.NewRoom, sym.FullFloorMarker))
                .PlaceCurrentFrom(what)
            );
        });
}
```

This time we need to find a `Node` with the symbol `sym.NewRoom` before we can start the production program. We declare this symbol to the `ProdParamsManager` using `AddNodeSymbol`. In the body of the production we can retrieve this symbol from `ProdParams` passed as a second parameter to the closure. 

We create the geometry for the room using `ldk.les.Box`, which works the same way as `ldk.les.Room` except that it doesn't set the style. We set the style manually using `SetAreaStyle`. The resulting `Node` from `Set` defines no symbols. That's because more operations are done on it before it's placed. Some operations might operate just on `LevelElement` or `CubeGroup`, discarding the original `Node` so it's a good idea to set the symbols as close before placing as possible. 

The method `MoveNearTo` built in the `ProductionProgram` moves the active nodes so that their floors are on the same level and they have the specified distance between the closest cubes. The `Change` just replaces all active nodes.

Let's create another production list and execute the corresponding grammar:

#### **`ShapeGrammarGenerator\ShapeGrammar\ProductionLists.cs`**
``` C#
public class ProductionLists
{
    ...

    public ProductionList NewGrammar()
    {
        return new ProductionList
        (
            pr.NewRoomNear()
        );
    }
}
```

#### **`LevelDesignLanguage\Modules\TestingModule.cs`**
``` C#
public void NewGrammar()
{
    Env.Execute(new RandomGrammar(Gr.PrL.NewStart(), 1));
    Env.Execute(new RandomGrammar(Gr.PrL.NewGrammar(), 40));
    Env.Execute(new AllGrammar(Gr.PrL.NewRoofs()));
}
```

The resulting environment looks like this:

![Many roofless rooms without foundations](./Images/ManyRooms.PNG)

Using the same methods as before, we can add the roofs and foundations to the rooms:

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
```C#
public Production NewRoomNear()
{
    return new Production(
        "New Room Near",
        new ProdParamsManager().AddNodeSymbols(sym.NewRoom),
        (state, pp) =>
        {
            var what = pp.Param;

            return state.NewProgram(prog => prog
                ...

                .CurrentFirst(out var newNode)
                .Found(out var foundation)
                .PlaceCurrentFrom(newNode)

                .Set(() => newNode)
                .ReserveUpward(2, sym.UpwardReservation)
                .PlaceCurrentFrom(newNode)
                );
        });
}
```

![Many houses](./Images/ManyHouses.PNG)

One issue you might have noticed is that the houses have no doors. The connections between `Node`s can be created by using methods of `ldk.con`. It defines factory methods for instances of `Connection`, which take two level elements and try to connect them. The simplest connection we can do is to just place a door:

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
```C#
public Production NewRoomNear()
{
    return new Production(
        "New Room Near",
        new ProdParamsManager().AddNodeSymbols(sym.NewRoom),
        (state, pp) =>
        {
            var what = pp.Param;

            return state.NewProgram(prog => prog
                ...

                .FindPath(() => ldk.con
                    .ConnectByDoor(AllAlreadyExisting(state, prog), AllExistingPaths(state, prog))
                        (newNode.LE, what.LE)
                        .GN(sym.ConnectionMarker), out var door)
                .PlaceCurrentFrom(what, newNode)
                );
        });
}
```

The call to place the door is placed inside `FindPath` because in general the two connected `Node`s might not be next to each other, in which case `FindPath` raises an error. The factory method `ConnectByDoor` takes two arguments - already existing geometry and already existing paths. Some connections can move through not yet taken space so they need information about existing geometry, but all connections need to make sure that they don't intersect another path. 

It might seem weird that `ConnectByDoor` doesn't move through outside and it still needs the information about existing geometry. This is because the factory method is sometimes passed as a parameter to a production that could take any path and having a single API simplifies the calls.

Once we receive the `Connection`, we apply it on the `LevelElement`s of the `Node` we derived and the one we took as a parameter. All connections should be marked with `sym.ConnectionMarker`, which can be used to query for them. When placing a connection, we set both areas it connects as its parents.

All of our houses are connected now:

![Many doors connecting rooms](./Images/ManyDoors.PNG)

We can again replace our production by call to a production template:

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
```C#
public Production NewRoomNear()
{
    return FullFloorPlaceNear(
            sym.NewRoom,
            sym.NewRoom,
            () => ldk.les.Box(3, 3, 2).SetAreaStyle(AreaStyles.Room()),
            EmptyOp(),
            Reserve(2, sym.UpwardReservation),
            ldk.con.ConnectByDoor,
            1
            );
}
```

Running through the copies of the same room might feel monotonous to the player. Let's add another production, this time for corridors:

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
```C#
public Production ExtrudeNewCorridor()
{
    return new Production(
        $"Extrude New Corridor",
        new ProdParamsManager().AddNodeSymbols(sym.NewRoom),
        (state, pp) =>
        {
            var from = pp.Param;
            var fromCG = from.LE.CG();

            return state.NewProgram(prog => prog
                .SelectFirstOne(
                    state.NewProgram(subProg => subProg
                        .Directional(ExtensionMethods.HorizontalDirections().Shuffle(),
                            dir =>
                                fromCG.ExtrudeDir(dir, 5).LE(AreaStyles.Room()).GN(sym.NewCorridor(dir), sym.FullFloorMarker)
                        )
                        .DiscardTaken()
                        .CanBeFounded()
                        ),
                    out var newNode
                    )
                .PlaceCurrentFrom(from)
                );
        });
}
```

#### **`ShapeGrammarGenerator\ShapeGrammar\Symbols.cs`**
``` C#
public class Symbols
{
    ...

    #region New symbols

    public Symbol NewRoom { get; } = new Symbol("NewRoom");
    public DirectionalSymbol NewCorridor(Vector3Int direction = default) => new DirectionalSymbol("NewCorridor", direction);

    #endregion
}
```

Instead of creating and positioning a new room, we extrude it out of one of the walls of the previous one. There are multiple directions in which we can extrude, these are given to the method `Directional` as its first parameter. The second parameter of `Directional` creates the corridor from given direction `dir` and the previous room. We introduced a new symbol `sym.NewCorridor()`, which remembers a direction that can be used later.

`Directional` adds `Node`s for all directions to the active nodes, but we would like to extrude only a single corridor. `SelectFirstOne` helps us with this - it takes a `ProductionProgram` as an input and it takes the first active node it finds or fails if such node doesn't exist. To increase the chance that the selected node results in a valid corridor, we filter out the nodes that intersect existing geometry or which can't have a foundation by `DiscardTaken` and `CanBeFounded`. To remove the bias of `SelectFirstOne` picking the first node created from a fixed order of directions we randomly `Shuffle` them.

Once we add the production to the production list, we get the following result:

#### **`ShapeGrammarGenerator\ShapeGrammar\ProductionLists.cs`**
``` C#
public class ProductionLists
{
    ...

    public ProductionList NewGrammar()
    {
        return new ProductionList
        (
            pr.NewRoomNear(),
            pr.ExtrudeNewCorridor()
        );
    }
}
```

![Rooms with roofs and corridors](./Images/RoomsAndCorridors.PNG)

The production we just wrote can fail, for example if the room is already surrounded by other rooms. If a single production fails, we only note the `Node` where it happened to not try to run it there again and then continue. A problem arises when there are no ways to apply any productions anymore, but we still haven't reached the number of `Node`s required by the `RandomGrammar`. In this case `NoApplicableProductionException` is thrown and the game generation decides to restart itself. Number of restarts can be seen in the log:

![Log showing how many times the generation was performed](./Images/ConstructionTriesNumber.PNG)

If we compose our level of a set of grammars so that most of the times the new environment can generated, then repeatedly restarting the game after failure will produce a valid level in a finite time, typically quite quickly. When creating or debugging a new grammar, we can often run into cases when the level can't be generated. `LDLanguage` defines a constant `MAX_NUMBER_OF_CONSTRUCTION_TRIES` which limits the maximum number of restarts. If correct result isn't generate in time, the final environment will be the one existing before the exception was thrown. In our case we can fail in `NewGrammar` which means that the roofs won't be generated:

![Rooms without roofs](./Images/GenerationFailed.PNG)

We could add the foundation, roof and connection to the rule again as before, but since the code is quite repetitive, let's replace the production with a template specialization:

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
```C#
public Production ExtrudeNewCorridor()
{
    return Extrude(
            sym.NewRoom,
            _ => ExtensionMethods.HorizontalDirections().Shuffle(),
            (cg, dir) => cg.ExtrudeDir(dir, 5).LE(AreaStyles.Room()).GN(sym.NewCorridor(dir), sym.FullFloorMarker),
            EmptyOp(),
            Reserve(2, sym.UpwardReservation),
            ldk.con.ConnectByDoor,
            true
        );
}
```

![Rooms with roofs and corridors without](./Images/RoomsRoofsCorridorsNo.PNG)

As you probably noticed on your generated result, the corridors don't have roofs. We defined roofs only `sym.NewRoom`. To create roofs for corridors, we have to duplicate the roof rule for corridors:

#### **`ShapeGrammarGenerator\ShapeGrammar\ProductionLists.cs`**
``` C#
public ProductionList NewRoofs()
{
    return new ProductionList
    (
        pr.Roof(pr.sym.NewRoom, 3, AreaStyles.CrossRoof()),
        pr.Roof(pr.sym.NewCorridor(), 3, AreaStyles.GableRoof()),
        
        pr.Roof(pr.sym.NewRoom, 2, AreaStyles.CrossRoof()),
        pr.Roof(pr.sym.NewCorridor(), 2, AreaStyles.GableRoof())
    );
}
```

![Rooms with roofs and corridors without](./Images/RoomsAndCorridorsWithRoofs.PNG)

We added the style `AreaStyles.GableRoof()` to the corridor, but you can use any of the roof styles defined in `AreaStyles`.

Currently our corridors have only 1 segment and don't lead anywhere. To fix the first issue, we can add a new production that extends the corridor:

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
```C#
public Production ExtendNewCorridor()
{
    return Extrude(
                sym.NewCorridor(),
                node => node.GetSymbol(sym.NewCorridor()).Direction.ToEnumerable(),
                (cg, dir) => cg.ExtrudeDir(dir, 5).LE(AreaStyles.Garden()).GN(sym.NewCorridor(dir), sym.FullFloorMarker),
                EmptyOp(),
                EmptyOp(),
                ldk.con.ConnectByDoor,
                true
            );
}
```

#### **`ShapeGrammarGenerator\ShapeGrammar\ProductionLists.cs`**
``` C#
public ProductionList NewGrammar()
{
    return new ProductionList
    (
        ...
        pr.ExtendNewCorridor()
    );
}
```

The production is using the same template as the previous one with a couple different parameters:

* the queried symbol is now `sym.NewCorridor()`,
* we pass in only one direction - the one we retrieve from the corridor symbol,
* the corridor isn't part of a building, but rather a garden, which also means that we don't need to make upward reservation anymore.

Long chains of corridors, like the one in the image below, are quite common result of the current production list. When we got corridors preventing any new productions before, the generation failed and we started anew, but now the corridors can be extended indefinitely.

![Rooms, corridors and gardens](./Images/ExtendingCorridors.PNG)

We typically don't want to have a symbol from which no other symbols can be derived - this reduces the variability of the outcome. The corridor is currently such a symbol. Let's fix it by generating a new room from a corridor:


#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
``` C#
public Production NewRoomFromNewCorridor()
{
    return FullFloorPlaceNear(
            sym.NewCorridor(),
            sym.NewRoom,
            () => ldk.les.Box(3, 3, 2).SetAreaStyle(AreaStyles.Room()),
            EmptyOp(),
            Reserve(2, sym.UpwardReservation),
            ldk.con.ConnectByStairsOutside,
            5
        );
}
```

#### **`ShapeGrammarGenerator\ShapeGrammar\ProductionLists.cs`**
``` C#
public ProductionList NewGrammar()
{
    return new ProductionList
    (
        ...
        pr.NewRoomFromNewCorridor()
    );
}
```

The production works pretty much the same as the one placing room next to another one, except that the new room is now further away (in the distance 5) and is no longer connected by a simple door, but rather a wooden path found by pathfinding. The result now looks much better:

![Rooms after bridges have appeared](./Images/RoomsAfterBridges.PNG)

One thing that could greatly help our environment to be more fun to explore is adding some vertical design to let the player look at the environment from above or to look forward to reaching the mysterious areas towering over the place.

Let's add the final production of this tutorial - a next floor for our `sym.NewRoom`: 

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
``` C#
public Production NewRoomNextFloor()
{
    return new Production(
        "New Room Next Floor",
        new ProdParamsManager()
            .AddNodeSymbols(sym.UpwardReservation(null))
            .SetCondition((state, pp) =>
            {
                bool correctBelowSymbol =
                    pp.Param.GetSymbol(sym.UpwardReservation(null))
                    .NodeReference.GetSymbol(sym.NewRoom) != null;
                return correctBelowSymbol && pp.Param.LE.CG().RightTopFront().y + 1 <= 20;
            }),
        (state, pp) =>
        {
            var nextFloorHeight = 2;
            var toExtrude = nextFloorHeight - 1;

            var reservation = pp.Param;
            var reservationCG = reservation.LE.CG();
            var roomBelow = pp.Param.GetSymbol(sym.UpwardReservation(null)).NodeReference;

            return state.NewProgram(prog => prog
                .Condition(() => toExtrude >= 0)
                .Set(() => reservation)
                .Change(res => res.LE.CG().BottomLayer()
                    .OpAdd().ExtrudeDir(Vector3Int.up, toExtrude).OpNew().LE().GN())
                .CurrentFirst(out var extendedReservation)

                // Only check if the part outside of the reservation was not taken yet
                .Condition(() => extendedReservation.LE.Minus(reservation.LE).CG().AllAreNotTaken())

                .Change(extr => extr.LE.CG().LE(AreaStyles.Room()).GN(sym.NewRoom, sym.FullFloorMarker))
                .CurrentFirst(out var nextFloor)
                .ReplaceNodes(reservation)
                );
        });
}
```

#### **`ShapeGrammarGenerator\ShapeGrammar\ProductionLists.cs`**
``` C#
public ProductionList NewGrammar()
{
    return new ProductionList
    (
        ...
        pr.NewRoomNextFloor()
    );
}
```

The production operates on the reservation, created by the node below. Productions query the symbols of existing nodes only based on their names so we can pass `sym.UpwardReservation(null)` to the `AddNodeSymbols` without specifying the `Node` which we haven't found yet. We still have to make sure that the node below has a correct symbol. This can be done in a condition for `ProdParamsManager`. In the condition we also limit the maximum height of at which the next floor can be created.

At the begining of the body we define some variables that are used in the program. We use `Condition` to fail the execution if the next floor height should be non-positive. To extrude the next floor we use `ExtrudeDir`, but this time we don't keep only the extruded part, we join it with the `BottomLayer()` of the reservation `CubeGroup` thanks to setting its mode by `OpAdd`.

Then we check if the part of the `extendedReservation` outside of the original `reservation` doesn't intersect already existing node and if it doesn't we replace `reservation` with a new room.

As usual, we now replace the rule with a template so that we don't have to copy and paste the code for new reservation and connection:

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
``` C#
public Production NewRoomNextFloor()
{
    return TakeUpwardReservation(
                sym.NewRoom,
                nextFloor => nextFloor.LE(AreaStyles.Room()).GN(sym.NewRoom, sym.FullFloorMarker),
                2,
                20,
                Reserve(2, sym.UpwardReservation),
                ldk.con.ConnectByWallStairsIn
                );
}
```

After running it we get an environment with multifloored houses:

![Houses most of which have different heights and various connections](./Images/VerticalLevel.PNG)

We can now customize the environment by assigning its `LevelElement`s different styles:


![The same environment with chapel style](./Images/ChapelEnvironment.PNG)

![The same environment with castle style](./Images/CastleEnvironment.PNG)


In this chapter the following changes to the files were made:

#### **`LevelDesignLanguage\Modules\MainModule.cs`**
``` C#
class MainModule : LDLanguage
{
    ...

    public void DeclareGame()
    {
        State.LC.AddNecessaryEvent($"New Grammar", 50, level => M.TestingModule.NewGrammar());
    }

    ...
}
```

#### **`LevelDesignLanguage\Modules\TestingModule.cs`**
``` C#
class TestingModule : LDLanguage
{
    ...

    public void NewGrammar()
    {
        Env.Execute(new RandomGrammar(Gr.PrL.NewStart(), 1));
        Env.Execute(new RandomGrammar(Gr.PrL.NewGrammar(), 40));
        Env.Execute(new AllGrammar(Gr.PrL.NewRoofs()));
    }
}
```

#### **`ShapeGrammarGenerator\ShapeGrammar\ProductionLists.cs`**
``` C#
public class ProductionLists
{
    ...

    public ProductionList NewStart()
    {
        return new ProductionList
        (
            pr.NewStart()
        );
    }
    
    public ProductionList NewGrammar()
    {
        return new ProductionList
        (
            pr.NewRoomNear(),
            pr.ExtrudeNewCorridor(),
            pr.ExtendNewCorridor(),
            pr.NewRoomFromNewCorridor(),
            pr.NewRoomNextFloor()
        );
    }

    public ProductionList NewRoofs()
    {
        return new ProductionList
        (
            pr.Roof(pr.sym.NewRoom, 3, AreaStyles.CrossRoof()),
            pr.Roof(pr.sym.NewCorridor(), 3, AreaStyles.GableRoof())
        );
    }
}
```

#### **`ShapeGrammarGenerator\ShapeGrammar\Productions.cs`**
``` C#
public class Productions
{
    ...

    #region NewGrammar

    public Production NewStart()
    {
        return Place(
            4, 
            () => ldk.les.Room(5, 5, 2), 
            le => le?.GN(sym.NewRoom, sym.LevelStartMarker, sym.FullFloorMarker), 
            Reserve(2, sym.UpwardReservation));
    }

    public Production NewRoomNear()
    {
        return FullFloorPlaceNear(
            sym.NewRoom,
            sym.NewRoom,
            () => ldk.les.Box(3, 3, 2).SetAreaStyle(AreaStyles.Room()),
            EmptyOp(),
            Reserve(2, sym.UpwardReservation),
            ldk.con.ConnectByDoor,
            1
            );
    }

    public Production ExtrudeNewCorridor()
    {
        return Extrude(
            sym.NewRoom,
            _ => ExtensionMethods.HorizontalDirections().Shuffle(),
            (cg, dir) => cg.ExtrudeDir(dir, 5).LE(AreaStyles.Room()).GN(sym.NewCorridor(dir), sym.FullFloorMarker),
            EmptyOp(),
            Reserve(2, sym.UpwardReservation),
            ldk.con.ConnectByDoor,
            true
        );
    }

    public Production ExtendNewCorridor()
    {
        return Extrude(
            sym.NewCorridor(),
            node => node.GetSymbol(sym.NewCorridor()).Direction.ToEnumerable(),
            (cg, dir) => cg.ExtrudeDir(dir, 5).LE(AreaStyles.Garden()).GN(sym.NewCorridor(dir), sym.FullFloorMarker),
            EmptyOp(),
            EmptyOp(),
            ldk.con.ConnectByDoor,
            true
        );
    }

    public Production NewRoomFromNewCorridor()
    {
        return FullFloorPlaceNear(
            sym.NewCorridor(),
            sym.NewRoom,
            () => ldk.les.Box(3, 3, 2).SetAreaStyle(AreaStyles.Room()),
            EmptyOp(),
            Reserve(2, sym.UpwardReservation),
            ldk.con.ConnectByStairsOutside,
            5
        );
    }

    public Production NewRoomNextFloor()
    {
        return TakeUpwardReservation(
            sym.NewRoom,
            nextFloor => nextFloor.LE(AreaStyles.Room()).GN(sym.NewRoom, sym.FullFloorMarker),
            2,
            20,
            Reserve(2, sym.UpwardReservation),
            ldk.con.ConnectByWallStairsIn
            );
    }

    #endregion
}
```

#### **`ShapeGrammarGenerator\ShapeGrammar\Symbols.cs`**
``` C#
public class Symbols
{
    ...

    #region New symbols

    public Symbol NewRoom { get; } = new Symbol("NewRoom");
    public DirectionalSymbol NewCorridor(Vector3Int direction = default) => new DirectionalSymbol("NewCorridor", direction);

    #endregion
}
```
